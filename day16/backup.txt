package main

import (
	"flag"
	"fmt"
	"math"
	"os"
	"strings"
	"time"
)

func main() {
	var inputFile = flag.String("inputFile", "../input/day16.example", "Relative file path to use as input.")
	flag.Parse()
	start := time.Now()
	fmt.Println("Running Part 1:")
	if err := Part1(*inputFile); err != nil {
		fmt.Println("Error in Part 2:", err)
		return
	}
	duration := time.Since(start)
	fmt.Printf("Execution Time: %s\n", duration)
}

func Part1(inputFile string) error {
	//scoreP1 := 0
	scoreP2 := 0
	//pq := &Queue{}
	bytes, err := os.ReadFile(inputFile)
	if err != nil {
		return err
	}

	// makeMatrix function will create the matrix from the input
	matrix, start, end, nodeMap, err := makeMatrix(bytes)
	if err != nil {
		return err
	}

	//fmt.Println(matrix)
	fmt.Println("Grid:")
	for _, row := range matrix {
		fmt.Println(row)
	}

	fmt.Println("Start: ", start)
	fmt.Println("End: ", end)
	fmt.Println("DistMap: ", nodeMap)
	fmt.Println("Node Count: ", len(nodeMap.List))

	// //Conduct breadth first search from each of the 0 positions on the map
	// for rows := range len(zeros) {
	// 	summitsP1 := BFS1(matrix, zeros[rows].row, zeros[rows].col)
	// 	summitsP2 := BFS2(matrix, zeros[rows].row, zeros[rows].col)

	// 	//fmt.Println("Summits from current run: ", summits)
	// 	scoreP1 += summitsP1
	// 	scoreP2 += summitsP2

	// }

	distance := Dijkstra(matrix, start, end)

	//fmt.Println("Summits Visited: ", len(summits))
	fmt.Println("Score Part 1: ", distance)
	fmt.Println("Score Part 2: ", scoreP2)
	return nil
}

///////////////////////////////////////////////////////////////////////////////

// makeMatrix takes the byte slice, splits it into lines and converts it into a 2D integer matrix.
// Also returns 0 positions in the matrix.
func makeMatrix(bytes []byte) ([][]string, Coordinate, Coordinate, Queue, error) {
	var matrix [][]string
	contents := string(bytes)
	lines := strings.Split(contents, "\n")
	var start, end Coordinate
	var nodeMap Queue
	//var nodeCount int
	//distMap := make(map[Coordinate]int)

	for rowIndex, line := range lines {
		if len(line) == 0 {
			continue
		}

		// Row to hold the integers
		row := make([]string, len(line))

		for colIndex, c := range line {

			// Assign the integer to the row
			row[colIndex] = string(c)

			// Check if the number is 0 and record the position
			if string(c) == "S" {
				start = Coordinate{X: rowIndex, Y: colIndex}
				nodeMap.Append(Coordinate{X: rowIndex, Y: colIndex, Dist: 0})
				fmt.Println("Starting Position: ", start)

			}

			if string(c) == "E" {
				end = Coordinate{X: rowIndex, Y: colIndex}
				nodeMap.Append(Coordinate{X: rowIndex, Y: colIndex, Dist: math.MaxInt32})
				fmt.Println("Ending Position: ", end)
			}

			if string(c) == "." {
				nodeMap.Append(Coordinate{X: rowIndex, Y: colIndex, Dist: math.MaxInt32})
			}
		}

		// Append the row to the matrix
		matrix = append(matrix, row)
	}

	// Return the created matrix and the list of zero positions
	return matrix, start, end, nodeMap, nil
}

type Summit struct {
	X, Y int
}

// Struct to represent a visited list of coordinates. Points is a slice of Coordinate structs.
type Visited struct {
	Points []Coordinate
}

// Struct to represent a coordinate on the grid. X and Y are integers.
type Coordinate struct {
	X    int
	Y    int
	Dist int
	Dir  [2]int
}

// Method to move the coordinate by a delta value. Delta is added to current coordinates.
func (c *Coordinate) Move(delta Coordinate) {
	c.X += delta.X
	c.Y += delta.Y
}

// Define the Queue struct to hold Coordinates
type Queue struct {
	List []Coordinate
}

func (q *Queue) Append(coordinate Coordinate) {
	q.List = append(q.List, coordinate)
}

func (pq *Queue) Enqueue(coordinate Coordinate) {
	// Add the coordinate at the end of the list
	pq.List = append(pq.List, coordinate)
	// Move the coordinate to its correct position
	pq.heapifyUp(len(pq.List) - 1)
}

// Dequeue removes the coordinate with the lowest priority (smallest distance)
func (pq *Queue) Dequeue() Coordinate {
	if len(pq.List) == 0 {
		fmt.Println("Priority queue is empty.")
		return Coordinate{} // Return an empty Coordinate if the queue is empty
	}

	// The top of the heap is always the smallest distance (lowest cost)
	coordinate := pq.List[0]

	// Move the last element to the top and heapify down
	pq.List[0] = pq.List[len(pq.List)-1]
	pq.List = pq.List[:len(pq.List)-1]
	pq.heapifyDown(0)

	return coordinate
}

// Function to check if the queue is empty
func (q *Queue) isEmpty() bool {
	return len(q.List) == 0
}

// Swap helper function
func (pq *Queue) swap(i, j int) {
	pq.List[i], pq.List[j] = pq.List[j], pq.List[i]
}

// Min-heapify function to maintain the priority queue property
func (pq *Queue) heapifyDown(index int) {
	left := 2*index + 1
	right := 2*index + 2
	smallest := index

	if left < len(pq.List) && pq.List[left].Dist < pq.List[smallest].Dist {
		smallest = left
	}

	if right < len(pq.List) && pq.List[right].Dist < pq.List[smallest].Dist {
		smallest = right
	}

	if smallest != index {
		pq.swap(index, smallest)
		pq.heapifyDown(smallest)
	}
}

// Min-heapify function to maintain the priority queue property while inserting
func (pq *Queue) heapifyUp(index int) {
	for index > 0 {
		parent := (index - 1) / 2
		if pq.List[index].Dist < pq.List[parent].Dist {
			pq.swap(index, parent)
			index = parent
		} else {
			break
		}
	}
}

// Part 1 Breadth First Search, tracking only unique paths
func BFS1(graph [][]int, r, c int) int {
	// Initializing the map that will keep track if the node is visited
	visited := make(map[Coordinate]bool)

	// Creating a Queue variable to store nodes to be processed
	var bfsQueue Queue

	directions := [][2]int{
		{-1, 0}, // Up
		{1, 0},  // Down
		{0, -1}, // Left
		{0, 1},  // Right
	}
	var summits []Summit

	// Marking current node as visited
	//isvisited[node] = true

	// Adding the current node to the queue
	bfsQueue.Enqueue(Coordinate{X: r, Y: c})
	visited[Coordinate{X: r, Y: c}] = true

	// Running a loop until the queue becomes empty
	for !bfsQueue.isEmpty() {
		currNode := bfsQueue.Dequeue()
		//fmt.Println(currNode)
		r := currNode.X
		c := currNode.Y
		//fmt.Println("Current Node: ", r, c)
		if graph[r][c] == 9 {
			//fmt.Println("Summit Found at :", r, c)
			summits = append(summits, Summit{X: r, Y: c})
		}

		for _, dir := range directions {
			nr, nc := r+dir[0], c+dir[1]
			if 0 <= nr && nr < len(graph) && 0 <= nc && nc < len(graph[0]) && graph[r][c]+1 == graph[nr][nc] && !visited[Coordinate{X: nr, Y: nc}] {
				visited[Coordinate{X: nr, Y: nc}] = true
				bfsQueue.Enqueue(Coordinate{X: nr, Y: nc})

			}
		}

		// Remove the current node from the queue after visiting it
	}
	//fmt.Println("Summits Found: ", summits)
	return len(summits)

}

// Part 2 BFS where the only difference is we do not track unique paths
func BFS2(graph [][]int, r, c int) int {
	// Initializing the map that will keep track if the node is visited
	visited := make(map[Coordinate]bool)

	// Creating a Queue variable to store nodes to be processed
	var bfsQueue Queue

	directions := [][2]int{
		{-1, 0}, // Up
		{1, 0},  // Down
		{0, -1}, // Left
		{0, 1},  // Right
	}
	var summits []Summit

	// Marking current node as visited
	//isvisited[node] = true

	// Adding the current node to the queue
	bfsQueue.Enqueue(Coordinate{X: r, Y: c})
	visited[Coordinate{X: r, Y: c}] = true

	// Running a loop until the queue becomes empty
	for !bfsQueue.isEmpty() {
		currNode := bfsQueue.Dequeue()
		//fmt.Println(currNode)
		r := currNode.X
		c := currNode.Y
		//fmt.Println("Current Node: ", r, c)
		if graph[r][c] == 9 {
			//fmt.Println("Summit Found at :", r, c)
			summits = append(summits, Summit{X: r, Y: c})
		}

		for _, dir := range directions {
			nr, nc := r+dir[0], c+dir[1]
			if 0 <= nr && nr < len(graph) && 0 <= nc && nc < len(graph[0]) && graph[r][c]+1 == graph[nr][nc] {
				visited[Coordinate{X: nr, Y: nc}] = true
				bfsQueue.Enqueue(Coordinate{X: nr, Y: nc})

			}
		}

		// Remove the current node from the queue after visiting it
	}
	//fmt.Println("Summits Found: ", summits)
	return len(summits)

}

// Part 1 Breadth First Search, tracking only unique paths
func Dijkstra(graph [][]string, start Coordinate, end Coordinate) int {
	// Initializing the map that will keep track if the node is visited
	visited := make(map[Coordinate]bool)
	//nodeCount := len(distMap)

	// Creating a Queue variable to store nodes to be processed
	pq := &Queue{}

	directions := [][2]int{
		{-1, 0}, // Up
		{1, 0},  // Down
		{0, -1}, // Left
		{0, 1},  // Right
	}
	//var summits []Summit
	distances := make(map[Coordinate]int)
	distances[start] = 0

	// Marking current node as visited
	//isvisited[node] = true

	// Adding the current node to the queue
	pq.Enqueue(start)
	visited[start] = true
	currentDir := directions[3]

	// Running a loop until the queue becomes empty
	for !pq.isEmpty() {
		currNode := pq.Dequeue()
		//fmt.Println(currNode)
		r := currNode.X
		c := currNode.Y
		//fmt.Println("Current Node: ", r, c)
		if graph[r][c] == "E" {
			//fmt.Println("Summit Found at :", r, c)
			fmt.Println("End of Path Reached")
			return currNode.Dist
		}

		// Skip if the node has already been visited with a shorter path
		if visited[Coordinate{X: r, Y: c}] {
			continue
		}

		for _, dir := range directions {
			nextDir := dir
			nr, nc := r+dir[0], c+dir[1]
			if 0 <= nr && nr < len(graph) && 0 <= nc && nc < len(graph[0]) && graph[nr][nc] != "#" {
				// Calculate the new distance for the neighbor
				newDist := currNode.Dist
				if currNode.Dir == dir {
					// Same direction: cost 1
					newDist += 1
				} else {
					// New direction: cost 1000
					newDist += 1000
				}

				// If we found a shorter path to the neighbor, update its distance
				if _, exists := distances[Coordinate{X: nr, Y: nc}]; !exists || newDist < distances[Coordinate{X: nr, Y: nc}] {
					distances[Coordinate{X: nr, Y: nc}] = newDist
					directionsFrom[Coordinate{X: nr, Y: nc}] = dir
					// Enqueue the neighbor with the updated distance and direction
					pq.Enqueue(&Coordinate{X: nr, Y: nc, Dist: newDist, Dir: dir})
				}
			}
		}
		return -1

	}
}

//fmt.Println("Summits Found: ", summits)
